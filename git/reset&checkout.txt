
===>>

三个区域:
	1.HEAD 指向最近一次commit里的所有snapshot
	2.Index 缓存区域，只有Index区域里的东西才可以被commit
	3.Working Directory 用户操作区域
	
	
@@@@@@@@@@@@@@@@@@@@@	
在提交层面上
@@@@@@@@@@@@@@@@@@@@@	
------------------------------------	
reset 版本回退
在提交层面上，reset将一个分支的末端指向另一个提交。这可以用来移除当前分支的一些提交。
比如，下面这两条命令让hotfix分支向后回退了两个提交。
git checkout hotfix 切换到分支 hotfix
git reset HEAD~2 版本回了2个提交。 (HEAD HEAD~1 HEAD~2)

参数：
--soft 返回对应的提交，但是对于工作区和缓存区都不修改。
		也就是说，当前工作区的东西不变，
		缓冲区域的东西也不变，所以经历了add
		
--mixed 默认方式 返回对应提交，但是工作区不修改，缓存区修改。
--hard 全部都修改。

当你传入HEAD以外的其他提交的时候要格外小心，因为reset操作会重写当前分支的历史。
正如Rebase黄金法则所说的，在公共分支上这样做可能会引起严重的后果

情况具体：
1 例如现在工作区域删除了一些文件，和修改了一些文件，想要全部还原。返回到上一次版本的情况
	这个时候可用  git reset --hard HEAD

--------------------------------------------------------
checkout : 实质是HEAD的移动
git checkout hotfix 
上面这个命令做的不过是将HEAD移到一个新的分支，然后更新工作目录。
这里的步骤可分成3步骤：
1.将HEAD指向那个分支的最后一次commit
2.将HEAD指向的commit里所有文件的snapshot替换掉Index区域里原来的内容
3.将Index区域里的内容填充到Working Directory里
https://segmentfault.com/a/1190000006185954

因为这可能会覆盖本地的修改，Git强制你提交或者缓存工作目录中的所有更改，
不然在checkout的时候这些更改都会丢失。
和git reset不一样的是，git checkout没有移动这些分支。

这对于快速查看项目旧版本来说非常有用。
但如果你当前的HEAD没有任何分支引用，那么这会造成HEAD分离。这是非常危险的，
如果你接着添加新的提交，然后切换到别的分支之后就没办法回到之前添加的这些提交。
因此，在为分离的HEAD添加新的提交的时候你应该创建一个新的分支。

--------------------------------------------------------
Revert 撤销一个提交的同时会创建一个新的提交
这是一个安全的方法，因为它不会重写提交历史。
相比git reset，它不会改变现在的提交历史。
因此，git revert可以用在公共分支上，git reset应该用在私有分支上。
你也可以把git revert当作撤销已经提交的更改，而git reset HEAD用来撤销没有提交的更改。




	
@@@@@@@@@@@@@@@@@@@@@	
文件层面
@@@@@@@@@@@@@@@@@@@@@	


---------------------------------------
reset
当检测到文件路径时，git reset 将缓存区同步到你指定的那个提交。
比如，下面这个命令会将倒数第二个提交中的foo.py加入到缓存区中，供下一个提交使用。
git reset HEAD~2 foo.py
和提交层面的git reset一样，通常我们使用HEAD而不是某个特定的提交。
运行git reset HEAD foo.py 会将当前的foo.py从缓存区中移除出去，
而不会影响工作目录中对foo.py的更改。
--soft、--mixed和--hard对文件层面的git reset毫无作用，
因为缓存区中的文件一定会变化，而工作目录中的文件一定不变。

---------------------------------------
checkout
Checkout一个文件和带文件路径git reset 非常像，除了它更改的是工作目录而不是缓存区。
不像提交层面的checkout命令，它不会移动HEAD引用，也就是你不会切换到别的分支上去。

比如，下面这个命令将工作目录中的foo.py同步到了倒数第二个提交中的foo.py。

git checkout HEAD~2 foo.py
和提交层面相同的是，它可以用来检查项目的旧版本，但作用域被限制到了特定文件。
如果你缓存并且提交了checkout的文件，它具备将某个文件回撤到之前版本的效果。
注意它撤销了这个文件后面所有的更改，而git revert 命令只撤销某个特定提交的更改。

和git reset 一样，这个命令通常和HEAD一起使用。
比如git checkout HEAD foo.py等同于舍弃foo.py没有缓存的更改。
这个行为和git reset HEAD --hard很像，但只影响特定文件。




命令	作用域	常用情景
git reset	提交层面	在私有分支上舍弃一些没有提交的更改
git reset	文件层面	将文件从缓存区中移除
git checkout	提交层面	切换分支或查看旧版本
git checkout	文件层面	舍弃工作目录中的更改
git revert	提交层面	在公共分支上回滚更改
git revert	文件层面	（然而并没有）
















